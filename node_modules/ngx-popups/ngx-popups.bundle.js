(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('ngx-dom-component')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'ngx-dom-component'], factory) :
	(factory((global['ngx-popup'] = {}),global.core,global.ngxDomComponent));
}(this, (function (exports,core,ngxDomComponent) { 'use strict';

// 08/06/2017
var DeferredPromise = /** @class */ (function () {
    function DeferredPromise(callback) {
        var _this = this;
        this._status = DeferredPromise.PENDING;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
            if (callback !== void 0) {
                callback.call(_this, _this);
            }
        }).then(function (value) {
            _this._status = DeferredPromise.RESOLVED;
            return value;
        }, function (error) {
            _this._status = DeferredPromise.REJECTED;
            throw error;
        });
    }
    DeferredPromise.resolve = function (value) {
        var promise = new DeferredPromise();
        promise.resolve(value);
        return promise;
    };
    DeferredPromise.reject = function (reason) {
        var promise = new DeferredPromise();
        promise.reject(reason);
        return promise;
    };
    Object.defineProperty(DeferredPromise.prototype, "status", {
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DeferredPromise.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: true,
        configurable: true
    });
    DeferredPromise.prototype.resolve = function (value) {
        if (this._status === DeferredPromise.PENDING) {
            this._resolve(value);
        }
        else {
            throw new TypeError('promise already resolved/rejected');
        }
    };
    DeferredPromise.prototype.reject = function (reason) {
        if (this._status === DeferredPromise.PENDING) {
            this._reject(reason);
        }
        else {
            throw new TypeError('promise already resolved/rejected');
        }
    };
    DeferredPromise.prototype.then = function (onFulfilled, onRejected) {
        var _this = this;
        return new DeferredPromise(function (deferred) {
            _this._promise.then(function (result) {
                try {
                    deferred.resolve(onFulfilled(result));
                }
                catch (error) {
                    deferred.reject(error);
                }
            }, function (reason) {
                if (onRejected === void 0) {
                    deferred.reject(reason);
                }
                else {
                    try {
                        deferred.resolve(onRejected(reason));
                    }
                    catch (error) {
                        deferred.reject(error);
                    }
                }
            });
        });
    };
    DeferredPromise.prototype.catch = function (onRejected) {
        var _this = this;
        return new DeferredPromise(function (deferred) {
            _this._promise.then(function (result) {
                deferred.resolve(result);
            }, function (reason) {
                try {
                    deferred.resolve(onRejected(reason));
                }
                catch (error) {
                    deferred.reject(error);
                }
            });
        });
    };
    DeferredPromise.RESOLVED = 'resolved';
    DeferredPromise.REJECTED = 'rejected';
    DeferredPromise.PENDING = 'pending';
    return DeferredPromise;
}());

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

(function (NgxPopupState) {
    NgxPopupState["CLOSED"] = "closed";
    NgxPopupState["CLOSING"] = "closing";
    NgxPopupState["OPENED"] = "opened";
    NgxPopupState["OPENING"] = "opening";
})(exports.NgxPopupState || (exports.NgxPopupState = {}));
var NgxPopupComponent = /** @class */ (function () {
    function NgxPopupComponent(ngxDOMComponentService, element) {
        this.ngxDOMComponentService = ngxDOMComponentService;
        this._closableListener = null;
        this._backgroundClosable = true;
        this._openPromise = null;
        this._closePromise = null;
        this._state = exports.NgxPopupState.CLOSED;
        this._element = element.nativeElement;
    }
    Object.defineProperty(NgxPopupComponent.prototype, "contentInstance", {
        /**
         * Returns the instance of the injected component.
         */
        get: function () {
            return this._ngxDOMComponent.instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPopupComponent.prototype, "element", {
        /**
         * Returns the DOM element of the popup
         * @returns {HTMLElement}
         */
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPopupComponent.prototype, "state", {
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPopupComponent.prototype, "closable", {
        get: function () {
            return this._closableListener === null;
        },
        set: function (value) {
            var _this = this;
            value = Boolean(value);
            var closable = (this._closableListener === null);
            if (value !== closable) {
                if (closable) {
                    var listener_1 = function (event) {
                        event.preventDefault();
                    };
                    this.addEventListener('beforeclose', listener_1);
                    this._closableListener = function () {
                        _this.removeEventListener('beforeclose', listener_1);
                        _this._closableListener = null;
                    };
                }
                else {
                    this._closableListener();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPopupComponent.prototype, "backgroundClosable", {
        get: function () {
            return this._backgroundClosable;
        },
        set: function (value) {
            this._backgroundClosable = Boolean(value);
        },
        enumerable: true,
        configurable: true
    });
    NgxPopupComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        this._ngxDOMComponentContainer = this.ngxDOMComponentService.createContainer(this.contentContainer);
        requestAnimationFrame(function () {
            _this.dispatchEvent(new CustomEvent('ready'));
        });
    };
    /**
     * The following events are available
     *
     * - open : after the popup is opened (including transition or not, according to 'waitTransitionEnd').
     * - close : after the popup is closed (including transition or not, according to 'waitTransitionEnd').
     * - beforeclose : when the close method is called. Use event.preventDefault() to cancel close.
     * - cancelopen : when an open is cancelled (ex: while animating, the popup is in a 'opening' state,
     *                if you call close before animation is complete, it cancels the open).
     *
     * All of them are CustomEvent, with a detail property that you can set when calling open or close.
     */
    NgxPopupComponent.prototype.addEventListener = function (type, listener, useCapture) {
        return this._element.addEventListener(type, listener, useCapture);
    };
    NgxPopupComponent.prototype.dispatchEvent = function (event) {
        return this._element.dispatchEvent(event);
    };
    NgxPopupComponent.prototype.removeEventListener = function (type, listener, useCapture) {
        return this._element.removeEventListener(type, listener, useCapture);
    };
    NgxPopupComponent.prototype.open = function (config, waitTransitionEnd, detail) {
        var _this = this;
        if (waitTransitionEnd === void 0) { waitTransitionEnd = true; }
        if (this._openPromise === null) {
            this._openPromise = new DeferredPromise(function () {
                switch (_this._state) {
                    case exports.NgxPopupState.CLOSED:
                    case exports.NgxPopupState.CLOSING:
                        var beforeOpenPrevented = !_this.dispatchEvent(new CustomEvent('beforeopen', {
                            detail: detail,
                            bubbles: false,
                            cancelable: true
                        }));
                        if (beforeOpenPrevented) {
                            _this._openPromise.reject(new Error("Open prevented"));
                        }
                        else {
                            if (_this._state === exports.NgxPopupState.CLOSING) {
                                _this.dispatchEvent(new CustomEvent('cancelclose'));
                                _this._closePromise.reject(new Error("Close cancelled"));
                            }
                            _this._state = exports.NgxPopupState.OPENING;
                            _this._build(config);
                            requestAnimationFrame(function () {
                                _this._element.classList.add('open');
                                if (waitTransitionEnd) {
                                    _this._waitTransitionEnd().then(function () {
                                        if (_this._openPromise !== null) {
                                            _this._openPromise.resolve();
                                        }
                                    });
                                }
                                else {
                                    _this._openPromise.resolve();
                                }
                            });
                        }
                        break;
                    default:
                        _this._openPromise.reject(new Error("Popup not closed"));
                        break;
                }
            });
            this._openPromise
                .then(function () {
                _this._state = exports.NgxPopupState.OPENED;
                _this._openPromise = null;
                _this.dispatchEvent(new CustomEvent('open', {
                    detail: detail
                }));
            }, function () {
                _this._openPromise = null;
            });
        }
        return this._openPromise.promise;
    };
    /**
     * Close the popup.
     *
     * @param waitTransitionEnd
     * @param detail
     * @returns {Promise<void>} - promise resolved when the popup is closed
     */
    NgxPopupComponent.prototype.close = function (waitTransitionEnd, detail) {
        var _this = this;
        if (waitTransitionEnd === void 0) { waitTransitionEnd = true; }
        if (this._closePromise === null) {
            this._closePromise = new DeferredPromise(function () {
                switch (_this._state) {
                    case exports.NgxPopupState.OPENED:
                    case exports.NgxPopupState.OPENING:
                        var beforeClosePrevented = !_this.dispatchEvent(new CustomEvent('beforeclose', {
                            detail: detail,
                            bubbles: false,
                            cancelable: true
                        }));
                        if (beforeClosePrevented) {
                            _this._closePromise.reject(new Error("Close prevented"));
                        }
                        else {
                            if (_this._state === exports.NgxPopupState.OPENING) {
                                _this.dispatchEvent(new CustomEvent('cancelopen'));
                                _this._openPromise.reject(new Error("Open cancelled"));
                            }
                            _this._state = exports.NgxPopupState.CLOSING;
                            _this._element.classList.remove('open');
                            if (waitTransitionEnd) {
                                _this._waitTransitionEnd().then(function () {
                                    if (_this._closePromise !== null) {
                                        _this._closePromise.resolve();
                                    }
                                });
                            }
                            else {
                                _this._closePromise.resolve();
                            }
                        }
                        break;
                    default:
                        _this._closePromise.reject(new Error("Popup not opened"));
                        break;
                }
            });
            this._closePromise
                .then(function () {
                _this._state = exports.NgxPopupState.CLOSED;
                _this._closePromise = null;
                _this.dispatchEvent(new CustomEvent('close', {
                    detail: detail
                }));
            }, function () {
                _this._closePromise = null;
            });
        }
        return this._closePromise.promise;
    };
    NgxPopupComponent.prototype.onClickBackground = function (event) {
        if (this._backgroundClosable && (event.target === this._element)) {
            this.close(true, event);
        }
    };
    NgxPopupComponent.prototype._build = function (config) {
        config.inputs = config.inputs || {};
        config.inputs['popup'] = this;
        this._ngxDOMComponent = this._ngxDOMComponentContainer.create(config);
    };
    NgxPopupComponent.prototype._waitTransitionEnd = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var transitionTime = _this._getTransitionTime(_this._element);
            if ((transitionTime === null) || (transitionTime > 10)) {
                setTimeout(resolve, transitionTime || 250);
                _this.addEventListener('transitionend', resolve, { once: true });
            }
            else {
                resolve();
            }
        });
    };
    NgxPopupComponent.prototype._getTransitionTime = function (element) {
        var computedStyle = window.getComputedStyle(element);
        if (computedStyle.transitionDuration) {
            var timeReg = new RegExp('([\\d\\.]+)((?:s)|(?:ms))', 'g');
            var timeMatch = timeReg.exec(computedStyle.transitionDuration);
            if (timeMatch !== null) {
                var time = parseFloat(timeMatch[1]);
                switch (timeMatch[2]) {
                    case 's':
                        return time * 1000;
                    case 'ms':
                        return time;
                }
            }
        }
        return null;
    };
    __decorate([
        core.ViewChild('contentContainer', { read: core.ViewContainerRef }),
        __metadata("design:type", core.ViewContainerRef)
    ], NgxPopupComponent.prototype, "contentContainer", void 0);
    __decorate([
        core.HostListener('click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], NgxPopupComponent.prototype, "onClickBackground", null);
    NgxPopupComponent = __decorate([
        core.Component({
            selector: 'ngx-popup',
            template: "\n   <div class=\"content\">\n    <ng-template #contentContainer></ng-template>\n   </div>\n  "
        }),
        __metadata("design:paramtypes", [ngxDomComponent.NgxDOMComponentService,
            core.ElementRef])
    ], NgxPopupComponent);
    return NgxPopupComponent;
}());

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NgxPopupService = /** @class */ (function () {
    function NgxPopupService() {
        this.managers = new Map();
    }
    NgxPopupService.prototype.registerManager = function (id, manager) {
        if (this.managers.get(id)) {
            throw new Error("Duplicate manager id: " + id);
        }
        this.managers.set(id, manager);
    };
    /**
     * Opens a new popup and inject a component inside.
     *
     * @param config - config of the component to inject
     * @param waitTransitionEnd - (default true) if true wait the end of the animation before triggering open/resolving promise.
     * @param detail - provide data to the 'detail' property of the custom event 'open'
     * @param managerId - in case of many managers, you can provide a specific manager id
     * @returns {Promise<NgxPopupComponent>} - promise resolved when the popup is opened
     */
    NgxPopupService.prototype.open = function (config, waitTransitionEnd, detail, managerId) {
        if (waitTransitionEnd === void 0) { waitTransitionEnd = true; }
        return this.getManager(managerId).open(config, waitTransitionEnd, detail);
    };
    /**
     * Closes a popup.
     *
     * @param popup - the popup to close
     * @param waitTransitionEnd - (default true) if true wait the end of the animation before triggering open/resolving promise.
     * @param detail - provide data to the 'detail' property of the custom event 'open'
     * @returns {Promise<void>} - promise resolved when the popup is closed
     */
    NgxPopupService.prototype.close = function (popup, waitTransitionEnd, detail) {
        if (waitTransitionEnd === void 0) { waitTransitionEnd = true; }
        return popup.close(waitTransitionEnd, detail);
    };
    /**
     * Closes all popups.
     *
     * @param managerId
     * @returns {Promise<void>} - promise resolved when all popups are closed.
     */
    NgxPopupService.prototype.closeAll = function (managerId) {
        return this.getManager(managerId).closeAll();
    };
    NgxPopupService.prototype.getManager = function (id) {
        var manager;
        if (id === void 0) {
            if (this.managers.size > 0) {
                manager = this.managers.values().next().value;
            }
            else {
                throw new Error("No manager for PopupService");
            }
        }
        else if (typeof id === 'string') {
            manager = this.managers.get(id);
            if (manager === void 0) {
                throw new Error("Invalid manager id: " + id);
            }
        }
        else {
            throw new TypeError("Expected string or undefined as id");
        }
        return manager;
    };
    NgxPopupService = __decorate$1([
        core.Injectable(),
        __metadata$1("design:paramtypes", [])
    ], NgxPopupService);
    return NgxPopupService;
}());

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// <ngx-popup
// *ngFor="let popupId of popupIds;"
// (popupReady)="onPopupReady($event)"
// (popupClosed)="onPopupClosed($event)"
//   [popupId]="popupId"
//   ></ngx-popup>
var NgxPopupsManagerComponent = /** @class */ (function () {
    function NgxPopupsManagerComponent(popupService, ngxDOMComponentService, element) {
        this.popupService = popupService;
        this.ngxDOMComponentService = ngxDOMComponentService;
        this._popups = [];
        this._element = element.nativeElement;
        if (!this._element.id) {
            this._element.id = 'popups-manager-' + Math.floor(Math.random() * 1e10).toString();
        }
        this.popupService.registerManager(this._element.id, this);
        this.checkVisibility();
    }
    NgxPopupsManagerComponent.prototype.ngAfterViewInit = function () {
        this._ngxDOMComponentContainer = this.ngxDOMComponentService.createContainer(this.popupsContainer);
    };
    NgxPopupsManagerComponent.prototype.open = function (config, waitTransitionEnd, detail) {
        var _this = this;
        return new Promise(function (resolve) {
            var ngxDOMComponent = _this._ngxDOMComponentContainer.create({
                componentType: NgxPopupComponent
            });
            _this._popups.push(ngxDOMComponent);
            _this.checkVisibility();
            var popup = ngxDOMComponent.instance;
            popup.addEventListener('ready', function () {
                resolve(popup.open(config, waitTransitionEnd, detail).then(function () {
                    return popup;
                }));
            }, { once: true });
            popup.addEventListener('close', function () {
                var index = _this._popups.indexOf(ngxDOMComponent);
                if (index >= 0) {
                    _this._popups[index].destroy();
                    _this._popups.splice(index, 1);
                    _this.checkVisibility();
                }
            }, { once: true });
        });
    };
    NgxPopupsManagerComponent.prototype.close = function (popup, waitTransitionEnd, detail) {
        return popup.close(waitTransitionEnd, detail);
    };
    NgxPopupsManagerComponent.prototype.closeAll = function () {
        return Promise.all(this._popups.slice(0) // clone to avoid removing popups before finishing
            .map(function (popup) {
            return popup.instance.close();
        })).then(function () { return void 0; });
    };
    NgxPopupsManagerComponent.prototype.checkVisibility = function () {
        this._element.classList.toggle('visible', this._popups.length > 0);
    };
    __decorate$2([
        core.ViewChild('popupsContainer', { read: core.ViewContainerRef }),
        __metadata$2("design:type", core.ViewContainerRef)
    ], NgxPopupsManagerComponent.prototype, "popupsContainer", void 0);
    NgxPopupsManagerComponent = __decorate$2([
        core.Component({
            selector: 'ngx-popups',
            template: "\n   <ng-template #popupsContainer></ng-template>\n  "
        }),
        __metadata$2("design:paramtypes", [NgxPopupService,
            ngxDomComponent.NgxDOMComponentService,
            core.ElementRef])
    ], NgxPopupsManagerComponent);
    return NgxPopupsManagerComponent;
}());

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NgxPopupModule = /** @class */ (function () {
    function NgxPopupModule() {
    }
    NgxPopupModule = __decorate$3([
        core.NgModule({
            imports: [ngxDomComponent.NgxDOMComponentModule],
            declarations: [
                NgxPopupComponent, NgxPopupsManagerComponent
            ],
            providers: [
                NgxPopupService
            ],
            exports: [
                NgxPopupComponent, NgxPopupsManagerComponent
            ],
            entryComponents: [
                NgxPopupComponent
            ]
        })
    ], NgxPopupModule);
    return NgxPopupModule;
}());

exports.NgxPopupModule = NgxPopupModule;
exports.NgxPopupService = NgxPopupService;
exports.NgxPopupComponent = NgxPopupComponent;
exports.NgxPopupsManagerComponent = NgxPopupsManagerComponent;
exports.DeferredPromise = DeferredPromise;

Object.defineProperty(exports, '__esModule', { value: true });

})));
